{"version":3,"sources":["lib/components/tooltip/tooltip.js","lib/components/charts/bar-chart/index.js","lib/components/charts/pie-chart/components/Pie.js","lib/components/charts/pie-chart/components/Scale.js","lib/components/charts/pie-chart/components/PieGroup.js","lib/components/charts/pie-chart/index.js","lib/components/charts/donut-chart/components/Donut.js","lib/components/charts/donut-chart/components/Scale.js","lib/components/charts/donut-chart/components/DonutGroup.js","lib/components/charts/donut-chart/index.js","App.js","reportWebVitals.js","index.js"],"names":["ToolTip","props","data","name","value","x","y","width","height","fill","cornerRadius","text","fontStyle","BarChart","options","React","useState","dataPlotted","label","toolTipData","setToolTipData","showToolTip","setShowToolTip","groupRef","useRef","showGrid","undefined","groupId","nanoid","labels","dataToPlot","datasets","minVal","Math","min","maxVal","max","absoluteMax","abs","a","ceil","length","b","toString","parseInt","pow","scaleFactor","scaleSuffix","yAxisInt","positiveTicks","negativeTicks","yAxisTicks","labelLength","horizontalInterval","verticalInterval","reDraw","e","current","getLayer","batchDraw","HorizontalLines","verticalIndex","Array","map","item","i","console","log","id","yLabel","listening","points","strokeWidth","stroke","VerticalLines","Bars","graphRange","barRatio","bw","bh","onMouseOver","gid","evt","pageX","pageY","target","setAttrs","setHoverProps","onMouseOut","resetHoverProps","ref","draggable","onClick","Pie","radius","total","rotation","totalInput","didHover","position","hover","setHover","product","angle","backgroundColor","strokeColor","onMouseDown","scaleX","scaleY","shadowEnabled","opacity","shadowColor","shadowBlur","shadowOpacity","shadowOffsetX","shadowOffsetY","Scale","idx","slice","toUpperCase","PieGroup","groupValue","dataArray","isSelected","onSelect","onChange","hoverData","setHoverData","prevHoverId","setPreviousHoverId","shapeRef","trRef","useEffect","nodes","sum","reduce","totalDeg","getRotation","currentStart","xBuffer","yAxisBreakCount","getPosition","w","document","createElement","getContext","measureText","onTap","fontSize","boundBoxFunc","oldBox","newBox","Konva","window","PieChart","dataObject","selectedId","selectShape","combinedData","push","Util","getRandomColor","graphDetails","setGraphDetails","preValue","newAttrs","Donut","outerRadius","innerRadius","DonutGroup","DonutChart","App","dataPie","checkDeselect","getStage","innerWidth","innerHeight","onTouchStart","hoverBorderColor","borderWidth","responsive","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.36588ef4.chunk.js","sourcesContent":["import React from 'react'\nimport { Rect, Text, Group } from 'react-konva'\n\nconst ToolTip = (props) => {\n  const { name, value, x, y } = props.data\n  return (\n    <Group x={x} y={y}>\n      <Rect width={100} height={50} fill=\"rgba(0,0,0,0.9)\" cornerRadius={8} />\n      <Text fill=\"#fff\" text={name || ''} fontStyle=\"bold\" x={10} y={8} />\n      <Text fill=\"#fff\" text={value || ''} x={10} y={24} />\n    </Group>\n  )\n}\n\nexport default ToolTip\n","import React from \"react\";\nimport { Text, Line, Rect, Group } from \"react-konva\";\nimport { nanoid } from \"nanoid\";\nimport ToolTip from \"../../tooltip/tooltip\";\n\nconst BarChart = ({ data, width, height, options }) => {\n\n    /*---------------------State------------------------------------------------------------------------------------------------*/\n\n    const [toolTipData, setToolTipData] = React.useState({ x: null, y: null, dataPlotted: null, label: null })\n    const [showToolTip, setShowToolTip] = React.useState(false)\n    // const [labels, setLabels] = React.useState(data.labels);\n    // const [dataToPlot, setDataToPlot] = React.useState(data.datasets.data)\n\n    /*---------------------------------------------------------------------------------------------------------------------*/\n\n\n    /*---------------------refs------------------------------------------------------------------------------------------------*/\n\n    const groupRef = React.useRef();\n\n    /*------------------------------------------------------------------------------------------------------------------------*/\n\n    /*---------------------variables------------------------------------------------------------------------------------------------*/\n\n    const showGrid = options.showGrid === undefined ? true : options.showGrid;\n    const groupId = nanoid();\n    const labels = data.labels;\n    const dataToPlot = data.datasets.data;\n    const barWidth = 0.70; // 70% of interval \n    const minVal = Math.min(...dataToPlot);\n    const maxVal = Math.max(...dataToPlot);\n    let absoluteMax = maxVal;\n\n    if (Math.abs(minVal) > maxVal) absoluteMax = Math.abs(minVal);\n    let a = Math.ceil(absoluteMax / dataToPlot.length);\n    let b = a.toString().length;\n\n    if (b > 1) a = parseInt(a / Math.pow(10, b - 1)) * Math.pow(10, b - 1);\n    let scaleFactor = 0;\n    let scaleSuffix = \"\";\n    const yAxisInt = a;\n    const positiveTicks = Math.ceil(maxVal / a);\n    const negativeTicks = Math.ceil(-minVal / a);\n    const yAxisTicks = positiveTicks;\n    const labelLength = data.labels.length;\n    const horizontalInterval = width / labelLength;\n    const verticalInterval = height / yAxisTicks;\n    if (absoluteMax > 10000000) {\n        scaleFactor = 1000000;\n        scaleSuffix = \"M\";\n    } else if (absoluteMax > 10000) {\n        scaleFactor = 1000;\n        scaleSuffix = \"K\";\n    } else {\n        scaleFactor = 1;\n        scaleSuffix = \"\";\n    }\n    /*---------------------------------------------------------------------------------------------------------------------*/\n\n\n    /*-------------------------------------functions--------------------------------------------------------------------------------*/\n\n    const reDraw = (e) => {\n        groupRef.current.getLayer().batchDraw();\n    }\n\n    const setHoverProps = (e, gid, dataPlotted, label) => {\n        setShowToolTip(true);\n        console.log(e.evt)\n        setToolTipData({\n            x: e.evt.pageX + horizontalInterval / 2,\n            y: e.evt.pageY - 20,\n            value: dataPlotted,\n            name: label,\n        });\n        e.target.setAttrs({\n            stroke: \"rgba(255,99,132,1)\",\n            fill: \"rgba(255,99,132,0.4)\"\n        });\n\n        console.log(showToolTip)\n        reDraw(e);\n    }\n\n    const resetHoverProps = (e, gid) => {\n        console.log(\"out\")\n        setShowToolTip(false);\n        e.target.setAttrs({\n            stroke: \"rgba(255,99,132,1)\",\n            fill: \"rgba(255,99,132,0.2)\"\n        });\n        setToolTipData({\n            x: e.evt.pageX,\n            y: e.evt.pageY\n        });\n        reDraw(e);\n    };\n\n    const HorizontalLines = () => {\n        let verticalIndex = -negativeTicks;\n        return ([...Array(yAxisTicks + 1)].map((item, i) => {\n            console.log(\"looping\")\n            const y = height - (i * verticalInterval);\n            const id = nanoid();\n            let yLabel = verticalIndex * yAxisInt / scaleFactor;\n            console.log()\n            yLabel = yLabel.toString() + scaleSuffix;\n            verticalIndex++;\n            if (showGrid)\n                return (<>\n                    <Line listening={false} id={id} key={id} points={[-5, y, 0, y, width, y]} strokeWidth={0.9} stroke=\"#c1c1c1\" />\n                    <Text text={yLabel} y={y - 10} x={-40} fill=\"#000\" />\n                </>)\n            return (<Text text={yLabel} y={y - 10} x={-40} fill=\"#000\" />)\n        }));\n    };\n\n    const VerticalLines = () => {\n        // const horizontalInterval = (width / yAxisTicks);\n        return ([...Array(yAxisTicks)].map((item, i) => {\n            console.log(\"looping\")\n            const x = width - (i * horizontalInterval);\n            const id = nanoid();\n            console.log(\"show grid \", showGrid)\n            if (showGrid)\n                return (<><Line listening={false} id={id} key={id} points={[x, 0, x, height, x]} strokeWidth={0.9} stroke=\"#c1c1c1\" />\n                    <Text text={labels[i]} x={x - horizontalInterval} y={height + 5} fill=\"#000\" />\n                </>)\n            return (<Text text={labels[i]} x={x - horizontalInterval} y={height + 5} fill=\"#000\" />)\n        }));\n    };\n\n    const Bars = ({ groupId }) => {\n        const graphRange = yAxisTicks * yAxisInt;\n        return (labels.map((item, i) => {\n            const barRatio = dataToPlot[i] / graphRange;\n            const bw = (horizontalInterval * (barWidth * 100) / 100);\n            const bh = barRatio * height;\n            const x = (horizontalInterval * i) + (horizontalInterval - bw) / 2;\n            const y = height - bh;\n            const id = nanoid();\n            return (<Rect id={id} key={id} width={bw} height={bh} x={x} y={y} fill=\"rgba(255,99,132,0.2)\" stroke=\"rgba(255,99,132,1)\"\n                onMouseOver={(e) => setHoverProps(e, groupId, dataToPlot[i], labels[i])}\n                onMouseOut={(e) => resetHoverProps(e, groupId)} \n            />\n            )\n        }));\n    }\n\n    /*---------------------------------------------------------------------------------------------------------------------*/\n\n\n    return (\n        <>\n            <Group x={60} y={60} id={groupId} ref={groupRef} draggable={true}>\n                <Rect fill=\"#fff\" width={width} height={height}\n                    onClick={() => setShowToolTip(false)}\n                />\n\n                {/* horizontal lines */}\n                <HorizontalLines />\n\n                {/* vertical lines */}\n                <VerticalLines />\n\n                {/* bars */}\n                <Bars groupId={groupId} />\n\n            </Group>\n            {showToolTip && <ToolTip data={toolTipData} />}\n        </>)\n}\n\nexport default BarChart;\n","import React, { Fragment, useState } from 'react'\nimport { Wedge } from 'react-konva'\nimport ToolTip from '../../../tooltip/tooltip'\n\nconst Pie = ({\n  width,\n  height,\n  radius = 100,\n  data,\n  total,\n  rotation,\n  totalInput,\n}) => {\n  const [hover, setHover] = useState({\n    didHover: false,\n    position: null,\n    data: null,\n  })\n\n  //* --------------------------------- Methods -------------------------------- */\n  const onMouseOver = (e) => {\n    setHover({\n      didHover: true,\n      data: {\n        x: radius+20,\n        y: 0,\n        name: data.label,\n        value: data.value,\n      },\n    })\n  }\n\n  const onMouseOut = (e) => {\n    setHover({\n      didHover: false,\n      data: null,\n    })\n  }\n  //* -------------------------------------------------------------------------- */\n\n  return (\n    <Fragment>\n      <Wedge\n        name={data.product}\n        x={width / 4}\n        y={height / 2}\n        radius={radius}\n        angle={(360 / total) * data.value}\n        fill={data.backgroundColor}\n        stroke={hover.didHover ? data.strokeColor : null}\n        strokeWidth={hover.didHover ? data.strokeWidth : null}\n        rotation={rotation}\n        onMouseOver={onMouseOver}\n        onMouseOut={onMouseOut}\n        onMouseDown={onMouseOut}\n        scaleX={hover.didHover ? 1.1 : 1}\n        scaleY={hover.didHover ? 1.1 : 1}\n        shadowEnabled\n        opacity={hover.didHover ? 0.8 : 1}\n        shadowColor={hover.didHover ? 'black' : 'transparent'}\n        shadowBlur={hover.didHover ? 10 : 0}\n        shadowOpacity={hover.didHover ? 0.6 : 0}\n        shadowOffsetX={hover.didHover ? 10 : 0}\n        shadowOffsetY={hover.didHover ? 10 : 0}\n      />\n      {hover.didHover && (\n        <ToolTip data={hover.data} />\n      )}\n    </Fragment>\n  )\n}\n\nexport default Pie\n","import React, { Fragment, useRef } from 'react'\nimport { Text, Rect, Group } from 'react-konva'\n\nconst Scale = ({ idx, width, height, radius, data, position, totalInput }) => {\n  return (\n    <Group x={position.x} y ={position.y}>\n      <Rect\n        width={15}\n        height={10}\n        fill={data.backgroundColor}\n        // x={width / 5}\n        // y={height / 2 - idx * (height / 2 / totalInput)}\n        stroke=\"black\"\n        strokeWidth={1}\n      />\n      <Text\n        text={data.label.slice(0, 1).toUpperCase() + data.label.slice(1)}\n        x={width/10 +15}\n        width={400}\n        // y={height / 2 - idx * (height / 2 / totalInput)}\n        // fontSize={radius / 6}\n      />\n    </Group>\n  )\n}\n\nexport default Scale\n","import { nanoid } from 'nanoid'\nimport React, { Fragment, useRef, useEffect, useState } from 'react'\nimport { Group, Transformer, Text, Rect } from 'react-konva'\nimport ToolTip from '../../../tooltip/tooltip'\n\nimport Pie from './Pie'\nimport Scale from './Scale'\nconst PieGroup = ({\n  groupValue,\n  groupValue: { x, y, height, width, dataArray, label },\n  isSelected,\n  onSelect,\n  onChange,\n}) => {\n  //*? ----------------------------- React hooks ---------------------------- */\n\n  const [hoverData, setHoverData] = useState({\n    didHover: false,\n  })\n  const [showToolTip, setShowToolTip] = useState(false)\n  const [prevHoverId, setPreviousHoverId] = useState(null)\n\n  const shapeRef = useRef()\n  const trRef = useRef()\n  useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current])\n      trRef.current.getLayer().batchDraw()\n    }\n  }, [isSelected])\n  //*? -------------------------------------------------------------------------- */\n\n  // getting sum to find the percent of sector\n  const getSum = (combinedDataArray) =>\n    combinedDataArray.reduce((total, item) => total + item.value, 0)\n  let sum = getSum(dataArray)\n\n  // getRotation function to find where the wedge should start\n  let totalDeg = 0\n  let getRotation = (idx, item) => {\n    if (dataArray.length - 1 === idx) {\n      let current = totalDeg\n      totalDeg = 0\n      return current\n    } else {\n      let current = totalDeg\n      totalDeg += (360 / sum) * item.value\n      return current\n    }\n  }\n\n  // calculates the position where legends should be placed\n  let currentStart = 0\n  let xBuffer = 50\n  let yBuffer = 20\n  let yAxisBreakCount = 0\n\n  const getPosition = (item, idx) => {\n    const canvas = document.createElement('canvas')\n    const context = canvas.getContext('2d')\n    const w = context.measureText(item.label).width\n    if (currentStart > width) {\n      currentStart = 0\n      yAxisBreakCount++\n    }\n    const x = currentStart\n    currentStart = x + w + xBuffer\n    return { x: x, y: yBuffer * yAxisBreakCount }\n  }\n\n  return (\n    console.log('rerende'),\n    (\n      <Fragment>\n        <Group\n          x={x}\n          y={y}\n          height={height}\n          width={width}\n          draggable\n          onClick={onSelect}\n          onTap={onSelect}\n          ref={shapeRef}\n          // onDragEnd={(e) => {\n          //   onChange({ ...groupValue, x: e.target.x(), y: e.target.y() })\n          // }}\n          // onTransformEnd={(e) => {\n          //   const node = shapeRef.current\n          //   //   const scaleX = node.scaleX();\n          //   //   const scaleY = node.scaleY();\n          //   // we will reset it back\n          //   //   node.scaleX(1);\n          //   //   node.scaleY(1);\n          //   onChange({\n          //     ...groupValue,\n          //     x: node.x(),\n          //     y: node.y(),\n          //     // set minimal value\n          //     // width: Math.max(50, node.width() * scaleX),\n          //     // height: Math.max(node.height() * scaleY),\n          //     // ! instead of reseting it back and enlarging it to the dragged size..\n          //     //! just make the dragged size remain\n          //     width: Math.max(50, node.width()),\n          //     height: Math.max(node.height()),\n          //   })\n          // }}\n        >\n          <Rect\n            x={0}\n            width={width + xBuffer}\n            height={height + xBuffer}\n            fill=\"rgba(255,255,255,0.0)\"\n          />\n          {label ? (\n            <Text x={width / 2 - xBuffer} y={-50} fontSize={20} text={label} />\n          ) : null}\n\n          {/* //* This will return Scale\n           */}\n          <Group>\n            {dataArray.map((item, idx) => (\n              <Scale\n                key={nanoid()}\n                idx={idx}\n                width={width / 3}\n                height={height}\n                data={item}\n                position={getPosition(item, idx)}\n                totalInput={dataArray.length}\n              />\n            ))}\n          </Group>\n\n          {\n            //* this will return a piechart  */\n          }\n          <Group\n            x={width / 2 - xBuffer}\n            y={yBuffer * yAxisBreakCount + xBuffer}\n          >\n            {dataArray.map((item, idx) => (\n              <Pie\n                key={nanoid()}\n                idx={idx}\n                width={(2 * width) / 3}\n                height={height}\n                radius={(2 * width) / 3 > height / 2 ? height / 2 : width / 3}\n                data={item}\n                total={sum}\n                rotation={getRotation(idx, item)}\n                totalInput={dataArray.length}\n                setHoverData={setHoverData}\n                setShowToolTip={setShowToolTip}\n                prevHoverId={prevHoverId}\n                setPreviousHoverId={setPreviousHoverId}\n              />\n            ))}\n          </Group>\n        </Group>\n\n        {hoverData.didHover ? <ToolTip data={hoverData?.data} /> : null}\n\n        {isSelected && (\n          <Transformer\n            ref={trRef}\n            boundBoxFunc={(oldBox, newBox) => {\n              // limit resize\n              if (newBox.width < 50 || newBox.height < 50) {\n                return oldBox\n              }\n              return newBox\n            }}\n          />\n        )}\n      </Fragment>\n    )\n  )\n}\n\nexport default PieGroup\n","import React, { useState, useEffect, Fragment } from 'react'\n\nimport PieGroup from './components/PieGroup'\n\nconst Konva = window.Konva\nconst PieChart = ({\n  id,\n  data,\n  width,\n  height,\n  options,\n  x,\n  y,\n  selectedId,\n  selectShape,\n}) => {\n  // combine label,values,color to a array of objects\n  const createDataset = (dataObject) => {\n    return dataObject.labels.reduce((combinedData, data, idx) => {\n      combinedData.push({\n        label: data,\n        value: dataObject.datasets.data[idx],\n        backgroundColor: dataObject?.datasets?.backgroundColor\n          ? dataObject.datasets.backgroundColor[idx] ?  dataObject.datasets.backgroundColor[idx] : Konva.Util.getRandomColor()\n          : Konva.Util.getRandomColor(),\n      })\n      return combinedData\n    }, [])\n  }\n\n  //*? ------------------------- Hooks------------------------- */\n  const [graphDetails, setGraphDetails] = useState({\n    id,\n    x: x,\n    y: y,\n    width,\n    height,\n    label: data.datasets.label,\n    dataArray: createDataset(data),\n  })\n\n  useEffect(() => {\n    setGraphDetails((preValue) => {\n      return { ...preValue }\n    })\n  }, [])\n  //*? -------------------------------------------------------------------------- */\n\n  return (\n    <Fragment>\n      <PieGroup\n        groupValue={graphDetails}\n        isSelected={graphDetails.id === selectedId}\n        // onSelect={() => {\n        //   selectShape(graphDetails.id)\n        // }}\n        onChange={(newAttrs) => {\n          // const rects = rectangles.slice(); // rects[i] = newAttrs;\n          setGraphDetails(newAttrs)\n        }}\n      />\n    </Fragment>\n  )\n}\n\nexport default PieChart\n","import React, { Fragment, useState } from 'react'\nimport { Arc } from 'react-konva'\nimport ToolTip from '../../../tooltip/tooltip'\n\nconst Donut = ({\n  width,\n  height,\n  radius = 100,\n  data,\n  total,\n  rotation,\n  totalInput,\n}) => {\n  const [hover, setHover] = useState({\n    didHover: false,\n    position: null,\n    data: null,\n  })\n\n  //* --------------------------------- Methods -------------------------------- */\n  const onMouseOver = (e) => {\n    setHover({\n      didHover: true,\n      data: {\n        x: radius+20,\n        y: 0,\n        name: data.label,\n        value: data.value,\n      },\n    })\n  }\n\n  const onMouseOut = (e) => {\n    setHover({\n      didHover: false,\n      data: null,\n    })\n  }\n  //* -------------------------------------------------------------------------- */\n\n  return (\n    <Fragment>\n      <Arc\n        name={data.product}\n        x={width / 4}\n        y={height / 2}\n        outerRadius={radius}\n        innerRadius={radius/1.5}\n        angle={(360 / total) * data.value}\n        fill={data.backgroundColor}\n        stroke={hover.didHover ? data.strokeColor : null}\n        strokeWidth={hover.didHover ? data.strokeWidth : null}\n        rotation={rotation}\n        onMouseOver={onMouseOver}\n        onMouseOut={onMouseOut}\n        onMouseDown={onMouseOut}\n        scaleX={hover.didHover ? 1.1 : 1}\n        scaleY={hover.didHover ? 1.1 : 1}\n        shadowEnabled\n        opacity={hover.didHover ? 0.8 : 1}\n        shadowColor={hover.didHover ? 'black' : 'transparent'}\n        shadowBlur={hover.didHover ? 10 : 0}\n        shadowOpacity={hover.didHover ? 0.6 : 0}\n        shadowOffsetX={hover.didHover ? 10 : 0}\n        shadowOffsetY={hover.didHover ? 10 : 0}\n      />\n      {hover.didHover && (\n        <ToolTip data={hover.data} />\n      )}\n    </Fragment>\n  )\n}\n\nexport default Donut\n","import React from 'react'\nimport { Text, Rect, Group } from 'react-konva'\n\nconst Scale = ({ idx, width, height, data, position, totalInput }) => {\n  return (\n    <Group x={position.x} y ={position.y}>\n      <Rect\n        width={15}\n        height={10}\n        fill={data.backgroundColor}\n        stroke=\"black\"\n        strokeWidth={1}\n      />\n      <Text\n        text={data.label.slice(0, 1).toUpperCase() + data.label.slice(1)}\n        x={width/10 +15}\n        width={400}\n      />\n    </Group>\n  )\n}\n\nexport default Scale\n","import { nanoid } from 'nanoid'\nimport React, { Fragment, useRef, useEffect, useState } from 'react'\nimport { Group, Transformer, Text, Rect } from 'react-konva'\nimport ToolTip from '../../../tooltip/tooltip'\n\nimport Donut from './Donut'\nimport Scale from './Scale'\nconst DonutGroup = ({\n  groupValue,\n  groupValue: { x, y, height, width, dataArray, label },\n  isSelected,\n  onSelect,\n  onChange,\n}) => {\n  //*? ----------------------------- React hooks ---------------------------- */\n\n  const [hoverData, setHoverData] = useState({\n    didHover: false,\n  })\n  const [showToolTip, setShowToolTip] = useState(false)\n  const [prevHoverId, setPreviousHoverId] = useState(null)\n\n  const shapeRef = useRef()\n  const trRef = useRef()\n  useEffect(() => {\n    if (isSelected) {\n      // we need to attach transformer manually\n      trRef.current.nodes([shapeRef.current])\n      trRef.current.getLayer().batchDraw()\n    }\n  }, [isSelected])\n  //*? -------------------------------------------------------------------------- */\n\n  // getting sum to find the percent of sector\n  const getSum = (combinedDataArray) =>\n    combinedDataArray.reduce((total, item) => total + item.value, 0)\n  let sum = getSum(dataArray)\n\n  // getRotation function to find where the wedge should start\n  let totalDeg = 0\n  let getRotation = (idx, item) => {\n    if (dataArray.length - 1 === idx) {\n      let current = totalDeg\n      totalDeg = 0\n      return current\n    } else {\n      let current = totalDeg\n      totalDeg += (360 / sum) * item.value\n      return current\n    }\n  }\n\n  // calculates the position where legends should be placed\n  let currentStart = 0\n  let xBuffer = 50\n  let yBuffer = 20\n  let yAxisBreakCount = 0\n\n  const getPosition = (item, idx) => {\n    const canvas = document.createElement('canvas')\n    const context = canvas.getContext('2d')\n    const w = context.measureText(item.label).width\n    if (currentStart > width) {\n      currentStart = 0\n      yAxisBreakCount++\n    }\n    const x = currentStart\n    currentStart = x + w + xBuffer\n    return { x: x, y: yBuffer * yAxisBreakCount }\n  }\n\n  return (\n    console.log('rerende'),\n    (\n      <Fragment>\n        <Group\n          x={x}\n          y={y}\n          height={height}\n          width={width}\n          draggable\n          onClick={onSelect}\n          onTap={onSelect}\n          ref={shapeRef}\n          // onDragEnd={(e) => {\n          //   onChange({ ...groupValue, x: e.target.x(), y: e.target.y() })\n          // }}\n          // onTransformEnd={(e) => {\n          //   const node = shapeRef.current\n          //   //   const scaleX = node.scaleX();\n          //   //   const scaleY = node.scaleY();\n          //   // we will reset it back\n          //   //   node.scaleX(1);\n          //   //   node.scaleY(1);\n          //   onChange({\n          //     ...groupValue,\n          //     x: node.x(),\n          //     y: node.y(),\n          //     // set minimal value\n          //     // width: Math.max(50, node.width() * scaleX),\n          //     // height: Math.max(node.height() * scaleY),\n          //     // ! instead of reseting it back and enlarging it to the dragged size..\n          //     //! just make the dragged size remain\n          //     width: Math.max(50, node.width()),\n          //     height: Math.max(node.height()),\n          //   })\n          // }}\n        >\n          <Rect\n            x={0}\n            width={width + xBuffer}\n            height={height + xBuffer}\n            fill=\"rgba(255,255,255,0.0)\"\n          />\n          {label ? (\n            <Text x={width / 2 - xBuffer} y={-50} fontSize={20} text={label} />\n          ) : null}\n\n          {/* //* This will return Scale\n           */}\n          <Group>\n            {dataArray.map((item, idx) => (\n              <Scale\n                key={nanoid()}\n                idx={idx}\n                width={width / 3}\n                height={height}\n                data={item}\n                position={getPosition(item, idx)}\n                totalInput={dataArray.length}\n              />\n            ))}\n          </Group>\n\n          {\n            //* this will return a piechart  */\n          }\n          <Group\n            x={width / 2 - xBuffer}\n            y={yBuffer * yAxisBreakCount + xBuffer}\n          >\n            {dataArray.map((item, idx) => (\n              <Donut\n                key={nanoid()}\n                idx={idx}\n                width={(2 * width) / 3}\n                height={height}\n                radius={(2 * width) / 3 > height / 2 ? height / 2 : width / 3}\n                data={item}\n                total={sum}\n                rotation={getRotation(idx, item)}\n                totalInput={dataArray.length}\n                setHoverData={setHoverData}\n                setShowToolTip={setShowToolTip}\n                prevHoverId={prevHoverId}\n                setPreviousHoverId={setPreviousHoverId}\n              />\n            ))}\n          </Group>\n        </Group>\n\n        {hoverData.didHover ? <ToolTip data={hoverData?.data} /> : null}\n\n        {isSelected && (\n          <Transformer\n            ref={trRef}\n            boundBoxFunc={(oldBox, newBox) => {\n              // limit resize\n              if (newBox.width < 50 || newBox.height < 50) {\n                return oldBox\n              }\n              return newBox\n            }}\n          />\n        )}\n      </Fragment>\n    )\n  )\n}\n\nexport default DonutGroup\n","import React, { useState, useEffect, Fragment } from 'react'\n\nimport DonutGroup from './components/DonutGroup'\n\nconst Konva = window.Konva\nconst DonutChart = ({\n  id,\n  data,\n  width,\n  height,\n  options,\n  x,\n  y,\n  selectedId,\n  selectShape,\n}) => {\n  // combine label,values,color to a array of objects\n  const createDataset = (dataObject) => {\n    return dataObject.labels.reduce((combinedData, data, idx) => {\n      combinedData.push({\n        label: data,\n        value: dataObject.datasets.data[idx],\n        backgroundColor: dataObject?.datasets?.backgroundColor\n          ? dataObject.datasets.backgroundColor[idx] ?  dataObject.datasets.backgroundColor[idx] : Konva.Util.getRandomColor()\n          : Konva.Util.getRandomColor(),\n      })\n      return combinedData\n    }, [])\n  }\n\n  //*? ------------------------- Hooks------------------------- */\n  const [graphDetails, setGraphDetails] = useState({\n    id,\n    x: x,\n    y: y,\n    width,\n    height,\n    label: data.datasets.label,\n    dataArray: createDataset(data),\n  })\n\n  useEffect(() => {\n    setGraphDetails((preValue) => {\n      return { ...preValue }\n    })\n  }, [])\n  //*? -------------------------------------------------------------------------- */\n\n  return (\n    <Fragment>\n      <DonutGroup\n        groupValue={graphDetails}\n        isSelected={graphDetails.id === selectedId}\n        // onSelect={() => {\n        //   selectShape(graphDetails.id)\n        // }}\n        onChange={(newAttrs) => {\n          // const rects = rectangles.slice(); // rects[i] = newAttrs;\n          setGraphDetails(newAttrs)\n        }}\n      />\n    </Fragment>\n  )\n}\n\nexport default DonutChart\n","import React, { useState } from 'react'\n// import { nanoid } from 'nanoid'\nimport { Stage, Layer } from 'react-konva'\nimport { PieChart, BarChart,DonutChart } from './lib'\n\nfunction App() {\n  // Data passes as per Chart.js\n  const dataPie = {\n    labels: [\n      'Saudi Arabia',\n      'Russia',\n      'Iraq',\n      'United Arab Emirates',\n      'Canada',\n      'India',\n      'China',\n      'Fiji',\n      'North Korea',\n      'USA',\n      'Ghana',\n      'Rwanda',\n      'DRK',\n      'Chile',\n      'Nepal',\n      'Spain',\n    ],\n    datasets: {\n      label: 'Population ',\n      data: [\n        133.3,\n        86.2,\n        52.2,\n        51.2,\n        50.2,\n        20.2,\n        40.6,\n        10.2,\n        0.7,\n        9,\n        20,\n        90,\n        3,\n        30,\n        40,\n        60,\n      ],\n      backgroundColor: ['#FF6384', '#63FF84', '#84FF63', '#8463FF', '#6384FF'],\n    },\n  }\n\n  const dataBar = {\n    labels: [\n      'Jan',\n      'Feb',\n      'Mar',\n      'Apr',\n      'May',\n      'Jun',\n      'Jul',\n      'Aug',\n      'Sep',\n      'Oct',\n      'Nov',\n      'Dec',\n    ],\n    datasets: {\n      label: 'Population',\n      backgroundColor: [],\n      data: [6300, 200, 5520, 3760, 9, 320, 819, 1308, 405, 2101, 640, 1999],\n    },\n\n    hoverBorderColor: 'red',\n    borderWidth: 1,\n  }\n\n  const [selectedId, selectShape] = useState(null)\n\n  /* ----------------------------- Methods ---------------------------- */\n  // to deselect when clicked outside the transformer\n  const checkDeselect = (e) => {\n    const clickedOnEmpty = e.target === e.target.getStage()\n    if (clickedOnEmpty) {\n      selectShape(null)\n    }\n  }\n  /* -------------------------------------------------------------------------- */\n\n  return (\n    <Stage\n      width={window.innerWidth}\n      height={window.innerHeight}\n      onMouseDown={checkDeselect}\n      onTouchStart={checkDeselect}\n    >\n      <Layer>\n        <BarChart\n          data={dataBar}\n          width={600}\n          height={400}\n          x={0}\n          y={0}\n          options={{\n            responsive: true,\n          }}\n        />\n        \n\n        <PieChart\n          height={200}\n          width={200}\n          x={700}\n          y={100}\n          data={dataPie}\n          options={{\n            responsive: true,\n          }}\n          selectShape={selectShape}\n          selectedId={selectedId}\n        />\n        <DonutChart\n          height={200}\n          width={200}\n          x={950}\n          y={100}\n          data={dataPie}\n          options={{\n            responsive: true,\n          }}\n          selectShape={selectShape}\n          selectedId={selectedId}\n        />\n      </Layer>\n    </Stage>\n  )\n}\n\nexport default App\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}